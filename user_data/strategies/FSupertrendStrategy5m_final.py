"""
Supertrend strategy:
* Description: Generate a 3 supertrend indicators for 'buy' strategies & 3 supertrend indicators for 'sell' strategies
               Buys if the 3 'buy' indicators are 'up'
               Sells if the 3 'sell' indicators are 'down'
* Author: @juankysoriano (Juan Carlos Soriano)
* github: https://github.com/juankysoriano/
*** NOTE: This Supertrend strategy is just one of many possible strategies using `Supertrend` as indicator. It should on any case used at your own risk.
          It comes with at least a couple of caveats:
            1. The implementation for the `supertrend` indicator is based on the following discussion: https://github.com/freqtrade/freqtrade-strategies/issues/30 . Concretelly https://github.com/freqtrade/freqtrade-strategies/issues/30#issuecomment-853042401
            2. The implementation for `supertrend` on this strategy is not validated; meaning this that is not proven to match the results by the paper where it was originally introduced or any other trusted academic resources
"""
from datetime import datetime
from typing import Optional

import pandas_ta as ta
import talib.abstract as ta
from pandas import DataFrame

import freqtrade.vendor.qtpylib.indicators as qtpylib
from freqtrade.strategy import IStrategy, IntParameter


class FSupertrendStrategy5m_final(IStrategy):
    # Buy params, Sell params, ROI, Stoploss and Trailing Stop are values generated by 'freqtrade hyperopt --strategy Supertrend --hyperopt-loss ShortTradeDurHyperOptLoss --timerange=20210101- --timeframe=1h --spaces all'
    # It's encourage you find the values that better suites your needs and risk management strategies

    custom_info = {}

    INTERFACE_VERSION: int = 3
    # Buy hyperspace params:
    buy_params = {
        "buy_ema": 200,
        # "buy_m1": 1,
        # "buy_m2": 2,
        # "buy_m3": 3,
        # "buy_p1": 10,
        # "buy_p2": 11,
        # "buy_p3": 12,
    }

    # Sell hyperspace params:
    sell_params = {
        "sell_ema": 200,
        # "sell_m1": 1,
        # "sell_m2": 2,
        # "sell_m3": 3,
        # "sell_p1": 10,
        # "sell_p2": 11,
        # "sell_p3": 12,
    }

    # ROI table:
    # minimal_roi = {"0": 0.1, "30": 0.75, "60": 0.05, "120": 0.025}
    minimal_roi = {
        "0": 0.07
    }

    # minimal_roi = {"0": 1}

    # Stoploss:
    stoploss = -0.0565
    can_short = True

    # Trailing stop:
    use_exit_signal = True
    trailing_stop = True
    trailing_stop_positive = 0.004
    trailing_stop_positive_offset = 0.005
    trailing_only_offset_is_reached = True

    timeframe = "5m"

    startup_candle_count = 200

    buy_ema = IntParameter(190, 210, default=200, space="buy")
    # buy_m1 = IntParameter(1, 4, default=1)
    # buy_m2 = IntParameter(1, 4, default=2)
    # buy_m3 = IntParameter(1, 4, default=3)
    # buy_p1 = IntParameter(9, 15, default=10)
    # buy_p2 = IntParameter(9, 15, default=11)
    # buy_p3 = IntParameter(9, 15, default=12)

    sell_ema = IntParameter(190, 210, default=200, space="sell")

    # sell_m1 = IntParameter(1, 4, default=1)
    # sell_m2 = IntParameter(1, 4, default=2)
    # sell_m3 = IntParameter(1, 4, default=3)
    # sell_p1 = IntParameter(9, 15, default=10)
    # sell_p2 = IntParameter(9, 15, default=11)
    # sell_p3 = IntParameter(9, 15, default=12)

    plot_config = {
        'main_plot': {
            'SUPERT_10_1.0': {'color': 'cyan'},
            'SUPERT_11_2.0': {'color': 'cyan'},
            'SUPERT_12_3.0': {'color': 'cyan'},
            'sell_ema_200': {'color': 'blue'},
            'emaShort': {'color': 'white'},
            'sloss': {'color': 'red'}
        },
        'subplots': {
            'DMI': {
                'adx': {'color': 'white'},
                'minus_di': {'color': 'red'},
                'plus_di': {'color': 'green'},
            },
            'RSI': {
                'fastd_rsi': {'color': 'blue'},
                'fastk_rsi': {'color': 'orange'},
            }
        }
    }

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:

        dataframe.ta.supertrend(length=10, multiplier=1, append=True)
        dataframe.ta.supertrend(length=11, multiplier=2, append=True)
        dataframe.ta.supertrend(length=12, multiplier=3, append=True)

        for period in self.buy_ema.range:
            dataframe[f"sell_ema_{period}"] = ta.EMA(dataframe, timeperiod=period)

        for period in self.sell_ema.range:
            dataframe[f"buy_ema_{period}"] = ta.EMA(dataframe, timeperiod=period)

        dataframe["adx"] = ta.ADX(dataframe)
        dataframe["plus_di"] = ta.PLUS_DI(dataframe)
        dataframe["minus_di"] = ta.MINUS_DI(dataframe)
        dataframe["emaShort"] = ta.EMA(dataframe, timeperiod=3)

        stoch_rsi = ta.STOCHRSI(dataframe)
        dataframe['fastd_rsi'] = stoch_rsi['fastd']
        dataframe['fastk_rsi'] = stoch_rsi['fastk']

        dataframe['greens'] = dataframe['SUPERTd_10_1.0'] + dataframe['SUPERTd_11_2.0'] + dataframe['SUPERTd_12_3.0']
        dataframe['reds'] = dataframe['SUPERTd_10_1.0'] + dataframe['SUPERTd_11_2.0'] + dataframe['SUPERTd_12_3.0']

        return dataframe


    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[
            (dataframe["close"] > dataframe[f"buy_ema_{self.buy_ema.value}"])
            & (dataframe["close"].shift(1) > dataframe[f"buy_ema_{self.buy_ema.value}"].shift(1))
            # & (dataframe["close"] > dataframe["emaShort"])
            & (dataframe["greens"] == 3)
            & (dataframe["greens"].shift(1) == 2)

            # & (dataframe["plus_di"] > dataframe["plus_di"].shift(1))
            # & (dataframe["minus_di"] < dataframe["minus_di"].shift(1))
            # & (dataframe["adx"] > dataframe["adx"].shift(1))

            # & (dataframe['fastd_rsi'] > dataframe['fastk_rsi'])
            # & (dataframe['fastd_rsi'] < 20)

            & (dataframe["volume"] > 0),
            "enter_long",
        ] = 1

        dataframe.loc[
            (dataframe["close"] < dataframe[f"sell_ema_{self.sell_ema.value}"])
            & (dataframe["close"].shift(1) < dataframe[f"sell_ema_{self.buy_ema.value}"].shift(1))
            # & (dataframe["close"] < dataframe["emaShort"])
            & (dataframe["reds"] == -3)
            & (dataframe["reds"].shift(1) == -2)

            # & (dataframe["plus_di"] < dataframe["plus_di"].shift(1))
            # & (dataframe["minus_di"] > dataframe["minus_di"].shift(1))
            # & (dataframe["adx"] > dataframe["adx"].shift(1))

            # & (dataframe['fastd_rsi'] < dataframe['fastk_rsi'])
            # & (dataframe['fastd_rsi'] > 80)

            & (dataframe["volume"] > 0),
            "enter_short",
        ] = 1

        return dataframe


    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[
            False
            | (dataframe["reds"] < -1)
            | (qtpylib.crossed_above(dataframe["adx"], dataframe["plus_di"]))
            | (qtpylib.crossed_above(dataframe["minus_di"], dataframe["plus_di"]))
            | (qtpylib.crossed_below(dataframe['close'], dataframe['emaShort']))
            ,
            "exit_long",
        ] = 1

        dataframe.loc[
            False
            | (dataframe["greens"] > 1)
            | (qtpylib.crossed_below(dataframe["adx"], dataframe["minus_di"]))
            | (qtpylib.crossed_above(dataframe["plus_di"], dataframe["minus_di"]))
            | (qtpylib.crossed_below(dataframe['close'], dataframe['emaShort']))
            ,
            "exit_short",
        ] = 1

        return dataframe


    @property
    def protections(self):
        return [
            # {
            #     "method": "CooldownPeriod",
            #     "stop_duration_candles": 5
            # },
            # {
            #     "method": "MaxDrawdown",
            #     "lookback_period_candles": 48,
            #     "trade_limit": 20,
            #     "stop_duration_candles": 4,
            #     "max_allowed_drawdown": 0.2
            # },
            # {
            #     "method": "StoplossGuard",
            #     "lookback_period_candles": 24,
            #     "trade_limit": 4,
            #     "stop_duration_candles": 2,
            #     "only_per_pair": False
            # },
            # {
            #     "method": "LowProfitPairs",
            #     "lookback_period_candles": 6,
            #     "trade_limit": 2,
            #     "stop_duration_candles": 60,
            #     "required_profit": 0.02
            # },
            # {
            #     "method": "LowProfitPairs",
            #     "lookback_period_candles": 24,
            #     "trade_limit": 4,
            #     "stop_duration_candles": 2,
            #     "required_profit": 0.01
            # }
        ]


    def leverage(self, pair: str, current_time: datetime, current_rate: float,
                 proposed_leverage: float, max_leverage: float, entry_tag: Optional[str],
                 side: str, **kwargs) -> float:
        entry_tag = ''
        max_leverage = 1


        return max_leverage
